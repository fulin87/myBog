---
layout: post
title:  "消息队列学习笔记"
date:	2018-06-25 13:07:11 +0800
categories: MQ
---

### 消息队列的使用场景

 * 解耦
 * 最终一致性
 * 广播
 * 错峰与流控

### MQ的实现原理

mq的实现其实本质上还是生产者发送RPC请求给"消息队列服务端",然后消息队列服务端将数据进行存储，在适当的时候消息队列服务端发送RPC请求给消费端，消费端最后发送RPC请求给消息队列服务端完成消费确认。
因此：**消息队列可以简单的理解为是3次RPC请求加上暂存**


### activeMQ实战

#### activeMQ的安装

* 本地下载activeMQ
* 服务器如果没有上传命令，需要按照上传和下载命令

		yum install -y lrzsz

* 将本地的文件上传至服务器
* 解压

		tar zvxf apache-activemq-5.15.4-bin.tar.gz

* 启动

		cd /app/apache-activemq-5.15.4
		./bin/activemq start

* 访问控制台

		http://192.168.182.129:8161/admin

**注意**

		activemq依赖于jdk，需要提前在服务器上安装好jdk


#### JMS 

* JMS是什么

JMS ： Java Message Serivice ,Java 消息服务，是JavaEE中的一种技术

* JMS规范

JMS定义了JAVA中访问消息中间件的接口,并没有给予实现实现JMS接口的消息中间件称为JMS Provider，例如：ActiveMQ

* JMS provider: 实现JMS接口和规范的消息中间件
* JMS message: JMS的消息，JMS消息由以下三部分组成：
 
		1：消息头
		2：消息属性
		3：消息体：封装具体的消息数据

* JMS producer: 消息生产者，创建和发送JMS消息的客户端应用
* JMS consumer: 消息消费者，接收和处理JMS消息的客户端应用，消息的消费可以采用以下两种方式之一：

		1：同步消费：通过调用消费者的receive方法从目的地中显示提取消息,receive方法可以一直阻塞到消息到达。
		2：异步消费：客户端可以为消费者注册一个消息监听器，以定义在消息到达时所采取的动作

* JMS domains: 消息传递域，JMS规范中定义了两种消息传递域：

		1：点对点：PTP,
		   每个消息只能有一个消费者
		   消费者和生产者之间没有时间上的相关性。
		2：发布/订阅 ： pub/sub
		   每个消息可以有多个消费者
		   生成者和消费者有时间上的相关性，只能消费自其订阅之后的消息。
		   JMS规范允许客户端创建持久订阅，持久订阅可以消费订阅之前的消息

* Connection factory: 连接工厂,用来创建连接对象，以连接到JMS provider
* JMS Connection: 封装了客户端与JMS提供者之间的一个虚拟的连接
* JMS Session: 是生产和消费消息的一个单线程上下文

		会话用于创建消息生产者，消费者，消息等。会话提供了一个事务性的上下文，
		在这个上下文中，一组发送和接收被组合到了一个原子操作中。

* Destination: 消息发送到的目的地
* Acknowledge: 签收
* Transaction: 事务

* JMS消息类型

		TextMessage
		MapMessage
		BytesMessage
		StreamMessage
		ObjectMessage

* 消息的接收确认

		JMS消息只有在被确认之后，才认为已经被成功的消费了。
		消息的成功消费包括三个阶段：客户端接收消息，客户端处理消息和消息被确认
		在事物性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式，参数有以下三个可选值：
		Session.AUTO_ACKNOWLEDGE:客户端receive方法返回或者MessageListener.onMessage方法成功返回的时候，会话自动确认
		Session.CLIENT_ACKNOWLEDGE:客户端通过调用acknowledge方法确认消息，确认一个消息，将自动确认所有已被会话消费的消息
		Session.DUPS_ACKNOWLEDGE: 会话迟钝的确认消息的提交，可能会导致一些重复的消息

* 消息持久化

		JMS支持以下两种消息提交模式：
		PERSISTENT：指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失
		NON_PERSISTENT: 不要求JMS provider持久保存消息

