---
layout: post
title:  "老鸟眼中的JVM知识体系(2)-JVM内存模型"
date:	2018-12-05 18:07:11 +0800
categories: java
---

> 这里用自己的语言总结一下JVM的内存模型，方便查阅和复习

## JVM内存结构

JVM内存区域的划分

![](/content/image/JVM2.PNG)

### 程序计数器

* 一块比较小的内存空间
* 存储的是当前线程执行的字节码的行号（可以简单的这么理解）
* 线程独占的，没有线程互不干扰，每个线程都有自己的程序计数器
* java中的 **goto** 是唯一一个保留关键字，不让用户使用，JVM暂时也不使用，goto就是操作的程序计数器
* 程序计数器是唯一一个JVM规范没有规定OOM的内存区域

### 虚拟机栈

* 描述的是java方法执行的动态内存模式
* 每个方法执行都会创建一个栈帧，一个方法从执行到退出就是从入栈到出栈的过程
* 栈帧内存储的就是*局部变量表，操作数栈，动态链接，方法出口* 等
  * 局部变量表存放的是编译期可知的各种基本*数据类型，引起类型，returnAddress类型*
  * 局部变量表的内存空间在编译期完成分配，在方法运行期间不会改变局部变量表的大小
* 会出现OutOfMemeryError和StactOverFlowError异常
* **-Xss** 参数进行调整

### 本地方法栈

* Hotspot虚拟机不区分本地方法栈和虚拟机栈，其将这两块区域合二为一了
* JVM规范中本地方法栈是为执行Native方法服务的
* 本地方法栈也会出现OutOfMemeryError和StactOverFlowError异常

### 堆

* 存放对象的实例，GC收集器所管理的主要区域
* JVM管理的最大的一块内存区域
* 注意并不是所有的对象实例都是分配在堆中的，但是可以简单的理解为是分配在堆中的
* 平时所说的 *Eden,新生代，老年代*  这些术语描述的就是堆，目的是为了GC
* 会出现OutOfMemeryError异常
* **-Xms 和 -Xmx**参数来调整总大小
* **-XX:NewSize 和 -XX:MaxNewSize** 参数调整Eden的大小
* **-XX:SurvivorRatio** 参数来调整Survivor区域的大小

### 方法区

* 运行时常量池是方法区的一部分

* 存储VM加载的类信息，*常量池*，静态变量，JIT编译后的代码等数据
  * 类的版本
  * 字段信息
  * 方法，接口
  * 编译器生成的各种字面量，符号引用

* 在HotSpot VM中方法区和永久代是同一块区域。但是方法区和永久代并不等价，这一点需要注意
* HotSpot设计团队使用永久代来实现方法区。这样可以像管理堆一样来管理方法区
* 其他VM并不一定存在永久代，JVM规范中没有做永久代的说明
* HotSpot VM中方法区和堆不是同一块区域（可以这样理解）
* 方法区也会出现OutOfMemoryError
* **-XX:PermSize 及 -XX:MaxPermSize** 参数进行调整

### 直接内存

* 也叫堆外内存，不收JVM的制约
* Nio会使用直接内存。现在比较流行的Apache Ignite这个技术也会使用直接内存



## 对象

### 对象的创建

![](/content/image/JVM3.PNG)

* 图中黄色部分是对用户透明的，我们能干预的只有开始和结束的部分
* 从对象的创建过程可以知道，对象的创建不具备原子性，所以new运算符具有线程安全问题

* 对象的内存分配方式有两种：
  * 指针碰撞。如果GC收集器具有压缩整理的功能，可以使用这种方式
  * 空闲列表。如果GC收集器没有压缩整理的功能，可以使用这种方式
* 对象的创建也会有线程安全问题，多个线程同时创建对象的时候
  * 线程同步可以解决，但是效率很低
  * 本地线程分配缓存，每个线程先分配可用的堆内存区域，可以比较好的解决

### 对象的结构

* Header（对象头）
  * 自身运行时数据，也叫 **Mark Word**
    * *哈希值*  
    * *GC分代年龄* 
    * 锁状态标志
    * 偏向线程ID 和 偏向时间戳
  * 类型指针，并不是所有的VM都有这一部分。
  * 数组对象比较特别，会将数组长度也记录在对象头中
  * 32位系统中是32位，64位系统中是64位
* InstanceData
  * 对象成员变量的值
  * 相同宽度的值会放在一起，比如double/long放在一起，char/short放在一起，这样会出现父类的成员出现在子类的成员之前 
* Padding
  * 可以认为是一个占位符
  * 对其填充。HotSpot的自动类型管理系统要求对象的起始地址必须是8个字节的整数倍，如果不是8个字节的整数倍则用Padding进行填充

### 对象的访问定位

* JVM规范只规定了JVM栈中的引用指向堆中的一块区域，并没有说这一块区域就是对象本身
* 对象的访问定位有两种方式实现
  * **使用句柄池实现**，好处是对象地址的变化不会引起句柄地址的变化，但是效率不高
  * **使用直接指针**，好处是效率高，但是对象地址的变化会引起指针的变化。
* 不管是使用哪种方式实现对象的访问定位都需要解决两个问题
  * 解决到对象的引用
  * 解决到对象类型的引用