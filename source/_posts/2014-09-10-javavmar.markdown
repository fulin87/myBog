---
layout: post
title:  "java虚拟机学习笔记"
date:	2014-09-10 13:07:11 +0800
categories: java
---

> 对于一个java程序员来说，水平达到一定程度后，对java虚拟机进行深入的研究，是提升技术水平的必经之路，把学习java虚拟机过程中感觉有启发性和重要性的知识点记录下来，作为备忘录。

## java的含义

 java的起源 -->  跨平台 --> 字节码，虚拟机

 ![](/content/image/java3.PNG)  

 java : java语言规范，java虚拟机规范

## 虚拟机的类加载

 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

 类加载的过程

 ![](/content/image/java1.PNG)

 以上步骤中`加载、验证、准备、初始化和卸载`这5个阶段的顺序是确定的,类的加载过程必须按照这种顺序按部就班的开始，注意这里说的是开始而不是进行或完成，这是因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段的过程中调用，激活另外一个阶段。

 这里解析阶段在某些情况下可以在初始化之后再开始，这是为了支持java语言的运行时绑定

 什么时候开始类加载的第一阶段`加载`是由具体的虚拟机实现决定的，但是虚拟机规范严格要求

###验证（校验）

验证的目的是取保class文件的字节流中的信息符合当前JVM的要求，并且不会危害JVM自身的安全。验证主要包括四个阶段。

+ **文件格式验证**，此阶段是基于二进制字节流进行的，保证输入的字节流能够正确的解析并存储于方法区，格式上符合描述一个java类的信息要求，通过此阶段之后，字节流才会进入内存的方法取进行存储。
	
	* 是否已魔数 0xCAFEBABE开头
	* 主次版本号是否在当前虚拟机处理范围以内
	* 常量池中的常量是否有不被支持的类型
	* class文件本身是否有被删除或附加的信息
	* .....


+ **元数据验证**，发生在方法区中，主要对语义，语法，此法进行分析，检查这个类是否能够顺利的编译
+ **字节码验证**，发生在方法区中，主要对方法体进行验证分析，保证被验证的类在运行时不会危害JVM。这个阶段是最复杂的，也可以说是用程序来验证程序逻辑，涉及到一个著名的停机问题。
+ **符号引用验证**，目的是确保解析动作能正常执行。符号引用验证可以看做是对类自身以外的信息进行匹配性校验。

	* 符号引用中通过字符串描述的全限定名是否能找到对应的类
	* 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
	* 符合引用中的类，字段，方法的访问性是否可以被当前类访问
	* ......

## class文件结构

 java的跨平台目标就是由不同平台的JVM实现的，JVM只关心Class文件，同时JVM并不关心Class的来源是何种语言，因此，Class的文件结构就至关重要。

 java语言中的变量，关键字，运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码指令所能提供的语义描述能力肯定比java语言本身更强大，这也为其他语言实现一些有别于java的语言特性提供了基础。

 类或接口并不一定以class文件的形式存在，也可能是二进制数据流。

 魔数 	

	0xCAFEBABE

 版本号

	0x00000033

 常量池计数值

	0x0016


## Java内存模型

 Java内存模型的目的就是定义程序中各个变量的访问规则，就是在java虚拟机中将变量存储到内存和从内存中将变量取出这样的细节。

	这里说的变量包括 实例变量，静态变量和构成数组对象的元素。
	不包括局部变量和方法参数

 Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的

## java多线程

 线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址，文件I/O等），又可以独立调度（线程是CPU调度的基本单元）。     
 java中每个已经执行了start()方法且还未结束的java.lang.Thread类的实例就是一个线程，Thread类的大部分关键方式都是Native的，Native方法说明这个方法的实现没有使用或者无法实现平台无关的方法来实现（或者是为了追求效率不去实）。