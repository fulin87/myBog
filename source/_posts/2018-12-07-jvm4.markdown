---
layout: post
title:  "老鸟眼中的JVM知识体系(4)-垃圾收集器与内存分配回收策略"
date:	2018-12-06 19:07:11 +0800
categories: java
---

> 定位了内存中的垃圾之后，具体的垃圾收集是垃圾收集器进行的，垃圾收集器是垃圾收集算法的具体实现，JVM规范没有对垃圾收集器进行强制的规范，垃圾收集器的种类很多，不同的垃圾收集器在不同的业务场景下性能表现不一样，选择垃圾收集器的目的就是为了提升垃圾收集的效率



## 垃圾收集器

*下图展示了不同分代的收集器，以及收集器之间的配合关系*

![](E:\code\myBog\source\image\JVM4.PNG)



### Serial 收集器

* 使用复制算法
* 新生代收集器，GC时会造成Stop The World

* 最基本，历史最悠久的收集器
* 单线程的垃圾收集器
* 会明显造成线程的卡顿，影响用户体验
* Serial收集器不适合使用在服务端，但是可以适当的使用在内存分配小的客户端服务中
* 之所以会用在客户端（比如桌面应用）中，是因为桌面应用的JVM内存比较小停顿感小，单线程的效率还是比较高的



### ParNew 收集器

* 使用复制算法
* 新生代收集器，GC时会造成Stop The World

* 多线程的垃圾收集器
* 在服务端因为是多线程可以显著的降低停顿感



### Parallel Scavenge 收集器

* 使用复制算法
* 新生代收集器
* 多线程收集器，GC时会造成Stop The World
* 设计的目标是达到一个可控制的吞吐量

* > 吞吐量：CPU用于运行用户代码的时间与GC消耗的总时间的比值
  >
  > 吞吐量公式：（执行用户代码的时间） /  (执行用户代码的时间 + 执行垃圾回收的时间）

* > -XX:MaxGCPauseMillis 垃圾收集最大停顿时间
  >
  > -XX:GCTimeRatio 吞吐量大小（0，100）之间的值，默认是99



## 内存分配与回收策略

* 对象优先在Eden分配

* 大对象直接进入老年代，个 **-XX:PretenureSizeThreshold=3M** 设置大于等于3M的对象直接进入老年代

* 长期存活的对象进入老年代

  *  **-XX:MaxTenuringThreshold=15**  设置新生代对象晋升进老年的年龄
  * **-XX:TargetSurvivorRatio=70**         设置survivor区使用率达到70%时晋升进入老年代

  > *为 了 能 更 好 地 适 应 不 同 程 序 的 内 存 状 况， 虚 拟 机 并 不 是 永 远 地 要 求 对 象 的 年 龄 必 须 达 到 了 MaxTenuringThreshold 才 能 晋 升 老 年 代， 如 果 在 Survivor 空 间 中 相 同 年 龄 所 有 对 象 大 小 的 总 和 大 于 Survivor 空 间 的 一 半， 年 龄 大 于 或 等 于 该 年 龄 的 对 象 就 可 以 直 接 进 入 老 年 代， 无 须 等 到 MaxTenuringThreshold 中 要 求 的 年 龄*。

* 空间分配担保

  > *在 发 生 Minor GC 之 前， 虚 拟 机 会 先 检 查 老 年 代 最 大 可 用 的 连 续 空 间 是 否 大 于 新 生 代 所 有 对 象 总 空 间， 如 果 这 个 条 件 成 立， 那 么 Minor GC 可 以 确 保 是 安 全 的。 如 果 不 成 立， 则 虚 拟 机 会 查 看 HandlePromotionFailure 设 置 值 是 否 允 许 担 保 失 败。 如 果 允 许， 那 么 会 继 续 检 查 老 年 代 最 大 可 用 的 连 续 空 间 是 否 大 于 历 次 晋 升 到 老 年 代 对 象 的 平 均 大 小， 如 果 大 于， 将 尝 试 着 进 行 一 次 Minor GC， 尽 管 这 次 Minor GC 是 有 风 险 的； 如 果 小 于， 或 者 HandlePromotionFailure 设 置 不 允 许 冒 险， 那 这 时 也 要 改 为 进 行 一 次 Full GC* 。 这个过程就叫做空间分配担保。



### 参考资料

《深入理解JAVA虚拟机》 周志明

 